<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>PushBot - Мониторинг деплоев</title>
        <script src="https://cdn.tailwindcss.com"></script>
        <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
        <style>
            @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap');
            * {
                font-family: 'JetBrains Mono', 'Courier New', monospace;
            }
            body {
                background: #0d1117;
                color: #7ee787;
            }
            .terminal-border {
                border: 1px solid #30363d;
                background: #161b22;
            }
            .terminal-bg {
                background: #161b22;
                border: 1px solid #30363d;
            }
            .terminal-header {
                background: #0d1117;
                border-bottom: 1px dotted #30363d;
                color: #7ee787;
            }
            .terminal-divider {
                border-bottom: 1px dotted #30363d;
            }
            .terminal-button {
                background: transparent;
                border: none;
                color: #7ee787;
                padding: 0;
                margin: 0;
            }
            .terminal-button:hover {
                color: #58a6ff;
            }
            .terminal-button:disabled {
                color: #484f58;
            }
        </style>
    </head>
    <body class="bg-[#0d1117] text-[#7ee787] font-mono">
    {% raw %}
    <div id="app" class="relative">
        <header class="terminal-header py-4 mb-6">
            <div class="container mx-auto max-w-7xl px-5">
                <h1 class="text-center text-xl font-semibold">
                    <span class="text-[#7ee787]">$</span>
                    <span class="text-[#58a6ff] ml-2">pushbot</span>
                    <span class="text-[#8b949e] ml-2">monitoring deployments</span>
                </h1>
            </div>
        </header>

        <div class="container mx-auto max-w-7xl px-5">
            <!-- Деплои -->
            <div class="terminal-bg p-4 mb-4">
                <div class="flex items-center justify-between mb-4 pb-2 terminal-divider">
                    <h2 class="text-base font-semibold text-[#7ee787]">
                        <span class="text-[#f0883e]">$</span> deployments
                    </h2>
                    <div class="flex items-center gap-2">
                        <button 
                            class="terminal-button text-sm"
                            @click="refreshDeployments"
                            :disabled="loading.deployments"
                        >
                            [{{ loading.deployments ? 'LOADING...' : 'REFRESH' }}]
                        </button>
                        <button 
                            class="terminal-button text-sm"
                            @click="clearDeployments"
                            :disabled="loading.clearing"
                        >
                            [{{ loading.clearing ? 'CLEARING...' : 'CLEAR DEPLOYS' }}]
                        </button>
                    </div>
                </div>
                <div v-if="allDeployments.length === 0 && !loading.deployments" class="text-center py-10 text-[#8b949e]">
                    <span class="text-[#f0883e]">[INFO]</span> <span class="text-[#7ee787]">No deployments found</span>
                </div>
                <div v-else-if="loading.deployments" class="text-center py-10 text-[#8b949e]">
                    <span class="text-[#f0883e]">[LOADING]</span> <span class="text-[#7ee787]">Fetching data...</span>
                </div>
                <div v-else class="space-y-1">
                    <!-- Активные деплои (сверху, с жёлтой рамкой) -->
                    <template v-if="activeDeployments.length > 0">
                        <deployment-history-item
                            v-for="deployment in activeDeployments"
                            :key="'active-' + deployment.id"
                            :deployment="deployment"
                            :services="services"
                            :is-active="true"
                            @show-logs="showLogsDrawer"
                            @update-status="updateDeploymentStatus"
                        />
                    </template>
                    <!-- История деплоев -->
                    <template v-if="recentDeployments.length > 0">
                        <deployment-history-item
                            v-for="deployment in recentDeployments"
                            :key="'recent-' + deployment.id"
                            :deployment="deployment"
                            :services="services"
                            :is-active="false"
                            @show-logs="showLogsDrawer"
                        />
                    </template>
                </div>
                <div v-if="hasMoreDeployments && recentDeployments.length > 0 && !loading.deployments" class="mt-4 text-center">
                        <button 
                            @click="loadMoreDeployments"
                            :disabled="loading.more"
                            class="terminal-button text-sm"
                        >
                        [{{ loading.more ? 'LOADING...' : 'LOAD MORE +10' }}]
                    </button>
                </div>
            </div>

            <!-- Список сервисов -->
            <div class="terminal-bg p-4 mb-4">
                <div class="mb-4 pb-2 terminal-divider">
                    <h2 class="text-base font-semibold text-[#7ee787]">
                        <span class="text-[#f0883e]">$</span> services
                    </h2>
                </div>
                <div v-if="services.length === 0" class="text-center py-10 text-[#8b949e]">
                    <span class="text-[#f0883e]">INFO:</span> <span class="text-[#7ee787]">No services configured</span>
                </div>
                <div v-else class="space-y-2">
                    <div v-for="service in services" :key="service.id" class="terminal-border p-3">
                        <h3 class="text-sm font-semibold text-[#f0883e] mb-2">{{ service.name }}</h3>
                        <div class="text-xs text-[#8b949e] mb-3 space-y-1">
                            <p><span class="text-[#58a6ff]">repo:</span> <span class="text-[#7ee787]">{{ service.repository }}</span></p>
                            <p><span class="text-[#58a6ff]">path:</span> <span class="text-[#7ee787]">{{ service.path }}</span></p>
                            <p><span class="text-[#58a6ff]">branch:</span> <span class="text-[#7ee787]">{{ service.branch }}</span></p>
                        </div>
                        <button 
                            @click="deployService(service.id)" 
                            :disabled="deployingServices.includes(service.id)"
                            class="w-full terminal-button text-xs"
                        >
                            [{{ deployingServices.includes(service.id) ? 'DEPLOYING...' : 'DEPLOY' }}]
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Drawer для логов -->
        <div 
            v-if="logsDrawerOpen"
            class="fixed inset-0 z-50 overflow-hidden"
        >
            <!-- Overlay -->
            <div 
                class="absolute inset-0 bg-black bg-opacity-70"
                @click="closeLogsDrawer"
            ></div>
            
            <!-- Drawer панель -->
            <div 
                class="absolute right-0 top-0 h-full w-full max-w-3xl bg-[#161b22] terminal-border flex flex-col"
                @click.stop
            >
                <!-- Header -->
                <div class="flex items-center justify-between p-3 terminal-divider bg-[#161b22]">
                    <div>
                        <h3 class="text-sm font-semibold text-[#f0883e]">
                            <span class="text-[#7ee787]">$</span> {{ getServiceName(logsDrawerDeployment) || 'deployment logs' }}
                        </h3>
                        <p class="text-xs text-[#8b949e] mt-1" v-if="logsDrawerDeployment">
                            <span :class="logsDrawerDeployment.status === 'running' ? 'text-[#58a6ff]' : logsDrawerDeployment.status === 'queued' ? 'text-[#f0883e]' : logsDrawerDeployment.status === 'success' ? 'text-[#7ee787]' : logsDrawerDeployment.status === 'failed' ? 'text-[#f85149]' : 'text-[#8b949e]'">
                                {{ getStatusText(logsDrawerDeployment.status) }}
                            </span>
                            <span v-if="logsDrawerDeployment.commit_sha" class="ml-2 font-mono text-[#8b949e]">
                                {{ logsDrawerDeployment.commit_sha.substring(0, 7) }}
                            </span>
                        </p>
                    </div>
                    <button 
                        @click="closeLogsDrawer"
                        class="terminal-button text-xs"
                    >
                        [CLOSE]
                    </button>
                </div>
                
                <!-- Логи -->
                <div class="flex-1 overflow-y-auto bg-[#0d1117] text-[#7ee787] p-4 font-mono text-xs logs-drawer-content">
                    <div v-if="logsDrawerLogs.length === 0" class="text-[#f0883e] text-center py-8">
                        {{ logsDrawerDeployment && (logsDrawerDeployment.status === 'running' || logsDrawerDeployment.status === 'queued') ? 'LOADING LOGS...' : 'NO LOGS' }}
                    </div>
                    <div 
                        v-for="(log, index) in logsDrawerLogs" 
                        :key="index"
                        :class="['my-0.5 whitespace-pre-wrap break-words', log.type === 'stderr' ? 'text-[#f85149]' : 'text-[#7ee787]']"
                    >
                        {{ log.line }}
                    </div>
                </div>
            </div>
        </div>
    </div>
    {% endraw %}

    {% raw %}
    <script>
        const { createApp } = Vue;

        // Компонент карточки деплоя
        const DeploymentCard = {
            props: ['deployment', 'services', 'isActive'],
            data() {
                return {
                    logs: [],
                    eventSource: null,
                    showLogs: false
                };
            },
            computed: {
                serviceName() {
                    const service = this.services.find(s => s.id === this.deployment.service_id);
                    return service ? service.name : 'Unknown';
                },
                statusText() {
                    const statusMap = {
                        'queued': 'QUEUED',
                        'running': 'IN PROGRESS',
                        'success': 'SUCCESS',
                        'failed': 'FAIL'
                    };
                    return statusMap[this.deployment.status] || this.deployment.status.toUpperCase();
                },
                statusBadgeClass() {
                    const classes = {
                        'queued': 'bg-yellow-500 text-white',
                        'running': 'bg-primary-light text-white',
                        'success': 'bg-success text-white',
                        'failed': 'bg-danger text-white'
                    };
                    return classes[this.deployment.status] || 'bg-gray-500 text-white';
                },
                borderClass() {
                    const classes = {
                        'queued': 'border-l-4 border-yellow-500',
                        'running': 'border-l-4 border-primary-light',
                        'success': 'border-l-4 border-success',
                        'failed': 'border-l-4 border-danger'
                    };
                    return classes[this.deployment.status] || 'border-l-4 border-gray-400';
                },
                formattedStartTime() {
                    if (!this.deployment.started_at) return '';
                    return new Date(this.deployment.started_at).toLocaleString('ru-RU');
                },
                formattedEndTime() {
                    if (!this.deployment.finished_at) return '';
                    return new Date(this.deployment.finished_at).toLocaleString('ru-RU');
                },
                shortCommitSha() {
                    if (!this.deployment.commit_sha) return '';
                    return this.deployment.commit_sha.substring(0, 7);
                },
                truncatedMessage() {
                    if (!this.deployment.commit_message) return '';
                    return this.deployment.commit_message.length > 100
                        ? this.deployment.commit_message.substring(0, 100) + '...'
                        : this.deployment.commit_message;
                }
            },
            mounted() {
                if (this.isActive) {
                    this.connectToLogs();
                } else if (this.deployment.stdout || this.deployment.stderr) {
                    // Для завершенных деплоев загружаем логи из данных
                    if (this.deployment.stdout) {
                        this.deployment.stdout.split('\n').forEach(line => {
                            if (line.trim()) {
                                this.logs.push({ type: 'stdout', line: line });
                            }
                        });
                    }
                    if (this.deployment.stderr) {
                        this.deployment.stderr.split('\n').forEach(line => {
                            if (line.trim()) {
                                this.logs.push({ type: 'stderr', line: line });
                            }
                        });
                    }
                }
            },
            beforeUnmount() {
                if (this.eventSource) {
                    this.eventSource.close();
                }
            },
            methods: {
                connectToLogs() {
                    if (!this.isActive) return;
                    
                    this.eventSource = new EventSource(`/api/deployments/${this.deployment.id}/logs`);
                    
                    this.eventSource.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        
                        if (data.type === 'status') {
                            // Обновляем статус деплоя
                            this.$emit('update-status', {
                                id: this.deployment.id,
                                status: data.status,
                                exit_code: data.exit_code
                            });
                            this.eventSource.close();
                            return;
                        }
                        
                        // Добавляем лог
                        this.logs.push({
                            type: data.type,
                            line: data.line
                        });
                        
                        // Автопрокрутка
                        this.$nextTick(() => {
                            const container = this.$el.querySelector('.logs-container');
                            if (container) {
                                container.scrollTop = container.scrollHeight;
                            }
                        });
                    };
                    
                    this.eventSource.onerror = (error) => {
                        console.error('Ошибка SSE:', error);
                        this.eventSource.close();
                    };
                },
                toggleLogs() {
                    this.showLogs = !this.showLogs;
                }
            },
            template: `
                <div :class="['border border-gray-300 rounded-lg p-4 mb-4 bg-gray-50 transition-all duration-300', borderClass]">
                    <div class="flex justify-between items-center mb-2">
                        <div class="font-bold text-lg">{{ serviceName }}</div>
                        <span :class="['px-3 py-1 rounded-full text-xs font-bold uppercase', statusBadgeClass]">
                            {{ statusText }}
                        </span>
                    </div>
                    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-2 mb-2 text-sm text-gray-600">
                        <div v-if="formattedStartTime">
                            <span class="font-bold text-gray-800">Начало:</span> {{ formattedStartTime }}
                        </div>
                        <div v-if="formattedEndTime">
                            <span class="font-bold text-gray-800">Завершение:</span> {{ formattedEndTime }}
                        </div>
                        <div v-if="deployment.exit_code !== null && deployment.exit_code !== undefined">
                            <span class="font-bold text-gray-800">Код выхода:</span> {{ deployment.exit_code }}
                        </div>
                        <div v-if="shortCommitSha">
                            <span class="font-bold text-gray-800">Коммит:</span> {{ shortCommitSha }}
                        </div>
                        <div v-if="deployment.branch">
                            <span class="font-bold text-gray-800">Ветка:</span> {{ deployment.branch }}
                        </div>
                    </div>
                    <div v-if="truncatedMessage" class="my-2 italic text-gray-600">
                        {{ truncatedMessage }}
                    </div>
                    <div v-if="isActive || deployment.status === 'queued'">
                        <div v-if="deployment.status === 'queued'" class="bg-gray-100 text-gray-600 p-4 rounded mt-2 text-sm text-center">
                            Ожидание в очереди...
                        </div>
                        <div v-else class="bg-gray-900 text-gray-300 p-4 rounded mt-2 font-mono text-xs max-h-96 overflow-y-auto logs-container">
                            <div v-if="logs.length === 0" class="my-1 whitespace-pre-wrap break-words">Загрузка логов...</div>
                            <div 
                                v-for="(log, index) in logs" 
                                :key="index"
                                :class="['my-1 whitespace-pre-wrap break-words', log.type === 'stderr' ? 'text-red-400' : 'text-gray-300']"
                            >
                                {{ log.line }}
                            </div>
                        </div>
                    </div>
                    <button 
                        v-if="!isActive && deployment.status !== 'queued'"
                        @click="$emit('show-logs', deployment.id)"
                        class="mt-2 text-sm text-primary-light hover:text-blue-700 font-medium cursor-pointer"
                    >
                        Показать логи →
                    </button>
                </div>
            `
        };

        // Компонент для истории деплоев (компактный)
        const DeploymentHistoryItem = {
            props: {
                deployment: { type: Object, required: true },
                services: { type: Array, required: true },
                isActive: { type: Boolean, default: false }
            },
            data() {
                return {
                    logs: [],
                    eventSource: null
                };
            },
            data() {
                return {
                    logs: [],
                    showLogs: false
                };
            },
            computed: {
                serviceName() {
                    const service = this.services.find(s => s.id === this.deployment.service_id);
                    return service ? service.name : 'Unknown';
                },
                statusText() {
                    const statusMap = {
                        'queued': 'QUEUED',
                        'running': 'IN PROGRESS',
                        'success': 'SUCCESS',
                        'failed': 'FAIL'
                    };
                    return statusMap[this.deployment.status] || this.deployment.status.toUpperCase();
                },
                statusBadgeClass() {
                    const classes = {
                        'queued': 'text-[#f0883e]',
                        'running': 'text-[#58a6ff]',
                        'success': 'text-[#7ee787]',
                        'failed': 'text-[#f85149]'
                    };
                    return classes[this.deployment.status] || 'text-[#8b949e]';
                },
                borderClass() {
                    const classes = {
                        'queued': 'border-l-2 border-dotted border-[#f0883e]',
                        'running': 'border-l-2 border-dotted border-[#58a6ff]',
                        'success': 'border-l-2 border-dotted border-[#7ee787]',
                        'failed': 'border-l-2 border-dotted border-[#f85149]'
                    };
                    return classes[this.deployment.status] || 'border-l-2 border-dotted border-[#30363d]';
                },
                formattedStartTime() {
                    if (!this.deployment.started_at) return '';
                    const date = new Date(this.deployment.started_at);
                    return date.toLocaleString('ru-RU', { 
                        day: '2-digit', 
                        month: '2-digit', 
                        hour: '2-digit', 
                        minute: '2-digit',
                        second: '2-digit'
                    });
                },
                formattedEndTime() {
                    if (!this.deployment.finished_at) return '';
                    const date = new Date(this.deployment.finished_at);
                    return date.toLocaleString('ru-RU', { 
                        day: '2-digit', 
                        month: '2-digit', 
                        hour: '2-digit', 
                        minute: '2-digit',
                        second: '2-digit'
                    });
                },
                shortCommitSha() {
                    if (!this.deployment.commit_sha) return '';
                    return this.deployment.commit_sha.substring(0, 7);
                },
                duration() {
                    if (!this.deployment.started_at) return '';
                    const start = new Date(this.deployment.started_at);
                    const end = this.deployment.finished_at ? new Date(this.deployment.finished_at) : new Date();
                    const diff = Math.floor((end - start) / 1000);
                    if (diff < 60) return `${diff}с`;
                    const minutes = Math.floor(diff / 60);
                    const seconds = diff % 60;
                    return `${minutes}м ${seconds}с`;
                }
            },
            mounted() {
                if (this.isActive && (this.deployment.status === 'running' || this.deployment.status === 'queued')) {
                    this.connectToLogs();
                } else if (this.deployment.stdout || this.deployment.stderr) {
                    if (this.deployment.stdout) {
                        this.deployment.stdout.split('\n').forEach(line => {
                            if (line.trim()) {
                                this.logs.push({ type: 'stdout', line: line });
                            }
                        });
                    }
                    if (this.deployment.stderr) {
                        this.deployment.stderr.split('\n').forEach(line => {
                            if (line.trim()) {
                                this.logs.push({ type: 'stderr', line: line });
                            }
                        });
                    }
                }
            },
            beforeUnmount() {
                if (this.eventSource) {
                    this.eventSource.close();
                }
            },
            methods: {
                connectToLogs() {
                    if (!this.isActive || (this.deployment.status !== 'running' && this.deployment.status !== 'queued')) {
                        return;
                    }
                    
                    this.eventSource = new EventSource(`/api/deployments/${this.deployment.id}/logs`);
                    
                    this.eventSource.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        
                        if (data.type === 'status') {
                            this.$emit('update-status', {
                                id: this.deployment.id,
                                status: data.status,
                                exit_code: data.exit_code
                            });
                            this.eventSource.close();
                            return;
                        }
                        
                        this.logs.push({
                            type: data.type,
                            line: data.line
                        });
                    };
                    
                    this.eventSource.onerror = (error) => {
                        console.error('Ошибка SSE:', error);
                        this.eventSource.close();
                    };
                }
            },
            template: `
                <div 
                    :class="['hover:bg-[#21262d] cursor-pointer', isActive && (deployment.status === 'running' || deployment.status === 'queued') ? 'border-[#f0883e] border-2 border-dotted' : '']"
                    @click="$emit('show-logs', deployment.id)"
                >
                    <div class="flex items-center justify-between gap-2 text-sm">
                        <div class="flex items-center gap-2 flex-1 min-w-0">
                            <span class="text-[#7ee787]">></span>
                            <span class="font-semibold text-[#f0883e]">{{ serviceName }}</span>
                            <span :class="['font-semibold whitespace-nowrap', statusBadgeClass]">
                                {{ statusText }}
                            </span>
                            <span v-if="deployment.branch" class="text-[#8b949e] whitespace-nowrap">{{ deployment.branch }}</span>
                            <span v-if="deployment.exit_code !== null && deployment.exit_code !== undefined" 
                                  :class="['whitespace-nowrap', deployment.exit_code === 0 ? 'text-[#7ee787]' : 'text-[#f85149]']">
                                Exit Code: {{ deployment.exit_code }}
                            </span>
                        </div>
                        <span class="text-[#8b949e] whitespace-nowrap">
                            {{ formattedStartTime }}<span v-if="duration" class="text-[#58a6ff]"> ({{ duration }})</span>
                        </span>
                    </div>
                </div>
            `
        };

        // Главное приложение
        createApp({
            components: {
                DeploymentCard,
                DeploymentHistoryItem
            },
            data() {
                return {
                    activeDeployments: [],
                    recentDeployments: [],
                    services: [],
                    loading: {
                        deployments: false,
                        more: false,
                        clearing: false
                    },
                    refreshInterval: null,
                    deployingServices: [],
                    logsDrawerOpen: false,
                    logsDrawerDeployment: null,
                    logsDrawerLogs: [],
                    logsDrawerEventSource: null,
                    escHandler: null,
                    deploymentsLimit: 10,
                    hasMoreDeployments: true
                };
            },
            computed: {
                allDeployments() {
                    return [...this.activeDeployments, ...this.recentDeployments];
                }
            },
            mounted() {
                this.loadInitialData();
                // Автообновление активных деплоев каждые 5 секунд (без перезагрузки истории)
                this.refreshInterval = setInterval(() => {
                    this.refreshActiveDeploymentsSilent();
                }, 5000);
                // Обработчик ESC для закрытия drawer
                this.escHandler = (event) => {
                    if (event.key === 'Escape' && this.logsDrawerOpen) {
                        this.closeLogsDrawer();
                    }
                };
                document.addEventListener('keydown', this.escHandler);
            },
            beforeUnmount() {
                if (this.refreshInterval) {
                    clearInterval(this.refreshInterval);
                }
                if (this.escHandler) {
                    document.removeEventListener('keydown', this.escHandler);
                }
            },
            methods: {
                async loadInitialData() {
                    await Promise.all([
                        this.loadDeployments(),
                        this.loadServices()
                    ]);
                },
                async loadDeployments() {
                    this.loading.deployments = true;
                    this.deploymentsLimit = 10;
                    try {
                        const [activeResponse, recentResponse] = await Promise.all([
                            fetch('/api/deployments/active'),
                            fetch(`/api/deployments?limit=${this.deploymentsLimit + 1}`)
                        ]);
                        const activeData = await activeResponse.json();
                        const recentData = await recentResponse.json();
                        
                        // Используем Vue.set или прямое присваивание для реактивности
                        const activeList = activeData.active_deployments || [];
                        const recentList = recentData.deployments || [];
                        
                        // Исключаем активные деплои из истории
                        const activeIds = new Set(activeList.map(d => d.id));
                        const filteredRecent = recentList
                            .filter(d => d.status !== 'running' && d.status !== 'queued' && !activeIds.has(d.id));
                        
                        // Проверяем, есть ли ещё деплои (если вернулось больше, чем лимит)
                        this.hasMoreDeployments = filteredRecent.length > this.deploymentsLimit;
                        
                        // Берём только нужное количество
                        const limitedRecent = filteredRecent.slice(0, this.deploymentsLimit);
                        
                        // Присваиваем массивы напрямую для правильной реактивности
                        this.activeDeployments.splice(0, this.activeDeployments.length, ...activeList);
                        this.recentDeployments.splice(0, this.recentDeployments.length, ...limitedRecent);
                    } catch (error) {
                        console.error('Ошибка загрузки деплоев:', error);
                    } finally {
                        this.loading.deployments = false;
                    }
                },
                async loadMoreDeployments() {
                    this.loading.more = true;
                    const newLimit = this.deploymentsLimit + 10;
                    try {
                        const [activeResponse, recentResponse] = await Promise.all([
                            fetch('/api/deployments/active'),
                            fetch(`/api/deployments?limit=${newLimit + 1}`)
                        ]);
                        const activeData = await activeResponse.json();
                        const recentData = await recentResponse.json();
                        
                        const activeList = activeData.active_deployments || [];
                        const recentList = recentData.deployments || [];
                        
                        // Исключаем активные деплои из истории
                        const activeIds = new Set(activeList.map(d => d.id));
                        const filteredRecent = recentList
                            .filter(d => d.status !== 'running' && d.status !== 'queued' && !activeIds.has(d.id));
                        
                        // Проверяем, есть ли ещё деплои (если вернулось больше, чем новый лимит)
                        this.hasMoreDeployments = filteredRecent.length > newLimit;
                        
                        // Обновляем лимит
                        this.deploymentsLimit = newLimit;
                        
                        // Берём только нужное количество
                        const limitedRecent = filteredRecent.slice(0, this.deploymentsLimit);
                        
                        // Обновляем только историю, активные деплои не меняем
                        this.recentDeployments.splice(0, this.recentDeployments.length, ...limitedRecent);
                    } catch (error) {
                        console.error('Ошибка загрузки дополнительных деплоев:', error);
                    } finally {
                        this.loading.more = false;
                    }
                },
                async loadActiveDeployments() {
                    try {
                        const response = await fetch('/api/deployments/active');
                        const data = await response.json();
                        this.activeDeployments = data.active_deployments || [];
                    } catch (error) {
                        console.error('Ошибка загрузки активных деплоев:', error);
                    }
                },
                async refreshActiveDeploymentsSilent() {
                    // Тихое обновление без показа индикатора загрузки
                    try {
                        const response = await fetch('/api/deployments/active');
                        const data = await response.json();
                        const newDeployments = data.active_deployments || [];
                        
                        // Обновляем существующие деплои и добавляем новые
                        const existingIds = new Set(this.activeDeployments.map(d => d.id));
                        const newIds = new Set(newDeployments.map(d => d.id));
                        
                        // Обновляем существующие деплои по одному, чтобы избежать пересоздания компонентов
                        const toRemove = [];
                        this.activeDeployments.forEach((existingDeployment, index) => {
                            const newDeployment = newDeployments.find(nd => nd.id === existingDeployment.id);
                            if (newDeployment) {
                                // Обновляем только изменённые поля (Vue 3 автоматически отслеживает изменения)
                                Object.assign(existingDeployment, newDeployment);
                            } else if (!newIds.has(existingDeployment.id)) {
                                // Деплой завершён, помечаем для удаления
                                if (existingDeployment.status === 'success' || existingDeployment.status === 'failed') {
                                    toRemove.push(index);
                                    // Добавляем в историю, если его там ещё нет
                                    if (!this.recentDeployments.find(rd => rd.id === existingDeployment.id)) {
                                        this.recentDeployments.unshift({ ...existingDeployment });
                                        if (this.recentDeployments.length > 20) {
                                            this.recentDeployments.pop();
                                        }
                                    }
                                }
                            }
                        });
                        
                        // Удаляем завершённые деплои (в обратном порядке, чтобы индексы не сбились)
                        toRemove.reverse().forEach(index => {
                            this.activeDeployments.splice(index, 1);
                        });
                        
                        // Добавляем новые деплои
                        newDeployments.forEach(newDeployment => {
                            if (!existingIds.has(newDeployment.id)) {
                                this.activeDeployments.push(newDeployment);
                            }
                        });
                    } catch (error) {
                        console.error('Ошибка обновления активных деплоев:', error);
                    }
                },
                async loadRecentDeployments() {
                    this.loading.recent = true;
                    try {
                        const response = await fetch('/api/deployments?limit=20');
                        const data = await response.json();
                        const newDeployments = (data.deployments || [])
                            .filter(d => d.status !== 'running' && d.status !== 'queued')
                            .slice(0, 20);
                        
                        // Обновляем только если список действительно изменился
                        const currentIds = new Set(this.recentDeployments.map(d => d.id));
                        const newIds = new Set(newDeployments.map(d => d.id));
                        
                        // Проверяем, есть ли новые деплои
                        const hasNew = newDeployments.some(d => !currentIds.has(d.id));
                        const hasRemoved = this.recentDeployments.some(d => !newIds.has(d.id));
                        
                        if (hasNew || hasRemoved) {
                            // Обновляем только если есть изменения (новые или удалённые)
                            this.recentDeployments = newDeployments;
                        }
                        // Если изменений нет, не обновляем вообще - это предотвращает дёргания
                    } catch (error) {
                        console.error('Ошибка загрузки истории деплоев:', error);
                    } finally {
                        this.loading.recent = false;
                    }
                },
                async loadServices() {
                    try {
                        // Загружаем сервисы из начальных данных или через API
                        {% endraw %}
                        const servicesData = {{ services_json | safe }};
                        {% raw %}
                        this.services = servicesData || [];
                        
                        // Также загружаем через API для обновления
                        const response = await fetch('/api/services');
                        const data = await response.json();
                        if (data.services && data.services.length > 0) {
                            this.services = data.services;
                        }
                    } catch (error) {
                        console.error('Ошибка загрузки сервисов:', error);
                    }
                },
                async refreshDeployments() {
                    await this.loadDeployments();
                },
                async clearDeployments() {
                    if (!confirm('Are you sure you want to clear all completed deployments?')) {
                        return;
                    }
                    this.loading.clearing = true;
                    try {
                        const response = await fetch('/api/deployments/clear', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            }
                        });
                        
                        if (!response.ok) {
                            const error = await response.json();
                            alert(`Ошибка очистки деплоев: ${error.detail || 'Неизвестная ошибка'}`);
                            return;
                        }
                        
                        // Обновляем список деплоев после очистки
                        await this.loadDeployments();
                    } catch (error) {
                        console.error('Ошибка очистки деплоев:', error);
                        alert('Ошибка очистки деплоев: ' + error.message);
                    } finally {
                        this.loading.clearing = false;
                    }
                },
                async refreshActiveDeployments() {
                    await this.loadActiveDeployments();
                },
                async refreshRecentDeployments() {
                    try {
                        const response = await fetch(`/api/deployments?limit=${this.deploymentsLimit}`);
                        const data = await response.json();
                        // Исключаем активные деплои из истории
                        const activeIds = new Set(this.activeDeployments.map(d => d.id));
                        this.recentDeployments = (data.deployments || [])
                            .filter(d => d.status !== 'running' && d.status !== 'queued' && !activeIds.has(d.id))
                            .slice(0, this.deploymentsLimit);
                    } catch (error) {
                        console.error('Ошибка загрузки истории деплоев:', error);
                    }
                },
                updateDeploymentStatus(payload) {
                    const deployment = this.activeDeployments.find(d => d.id === payload.id);
                    if (deployment) {
                        deployment.status = payload.status;
                        deployment.exit_code = payload.exit_code;
                        // Перемещаем в историю через некоторое время (тихо, без перезагрузки)
                        setTimeout(() => {
                            this.refreshActiveDeploymentsSilent();
                            // Обновляем историю только если деплой завершён
                            if (payload.status === 'success' || payload.status === 'failed') {
                                this.refreshRecentDeployments();
                            }
                        }, 2000);
                    }
                },
                async deployService(serviceId) {
                    // Добавляем сервис в список запускающихся
                    if (this.deployingServices.includes(serviceId)) {
                        return;
                    }
                    this.deployingServices.push(serviceId);
                    
                    try {
                        const response = await fetch(`/api/services/${serviceId}/deploy`, {
                            method: 'POST'
                        });
                        
                        if (!response.ok) {
                            const error = await response.json();
                            alert(`Ошибка запуска деплоя: ${error.detail || 'Неизвестная ошибка'}`);
                            return;
                        }
                        
                        const data = await response.json();
                        console.log('Деплой запущен:', data);
                        
                        // Обновляем список активных деплоев
                        await this.refreshActiveDeployments();
                    } catch (error) {
                        console.error('Ошибка запуска деплоя:', error);
                        alert('Ошибка запуска деплоя: ' + error.message);
                    } finally {
                        // Удаляем сервис из списка запускающихся
                        const index = this.deployingServices.indexOf(serviceId);
                        if (index > -1) {
                            this.deployingServices.splice(index, 1);
                        }
                    }
                },
                async showLogsDrawer(deploymentId) {
                    // Находим деплой
                    let deployment = this.activeDeployments.find(d => d.id === deploymentId);
                    if (!deployment) {
                        deployment = this.recentDeployments.find(d => d.id === deploymentId);
                    }
                    
                    if (!deployment) {
                        // Загружаем деплой через API
                        try {
                            const response = await fetch(`/api/deployments/${deploymentId}`);
                            const data = await response.json();
                            deployment = data;
                        } catch (error) {
                            console.error('Ошибка загрузки деплоя:', error);
                            return;
                        }
                    }
                    
                    this.logsDrawerDeployment = deployment;
                    this.logsDrawerLogs = [];
                    
                    // Загружаем логи
                    if (deployment.status === 'running' || deployment.status === 'queued') {
                        // Подключаемся к SSE для активных деплоев
                        this.logsDrawerEventSource = new EventSource(`/api/deployments/${deploymentId}/logs`);
                        
                        this.logsDrawerEventSource.onmessage = (event) => {
                            const data = JSON.parse(event.data);
                            
                            if (data.type === 'status') {
                                this.logsDrawerEventSource.close();
                                this.logsDrawerEventSource = null;
                                return;
                            }
                            
                            this.logsDrawerLogs.push({
                                type: data.type,
                                line: data.line
                            });
                            
                            // Автопрокрутка
                            this.$nextTick(() => {
                                const drawer = document.querySelector('.logs-drawer-content');
                                if (drawer) {
                                    drawer.scrollTop = drawer.scrollHeight;
                                }
                            });
                        };
                        
                        this.logsDrawerEventSource.onerror = (error) => {
                            console.error('Ошибка SSE:', error);
                            this.logsDrawerEventSource.close();
                            this.logsDrawerEventSource = null;
                        };
                    } else {
                        // Загружаем логи из данных деплоя
                        if (deployment.stdout) {
                            deployment.stdout.split('\n').forEach(line => {
                                if (line.trim()) {
                                    this.logsDrawerLogs.push({ type: 'stdout', line: line });
                                }
                            });
                        }
                        if (deployment.stderr) {
                            deployment.stderr.split('\n').forEach(line => {
                                if (line.trim()) {
                                    this.logsDrawerLogs.push({ type: 'stderr', line: line });
                                }
                            });
                        }
                    }
                    
                    this.logsDrawerOpen = true;
                },
                closeLogsDrawer() {
                    if (this.logsDrawerEventSource) {
                        this.logsDrawerEventSource.close();
                        this.logsDrawerEventSource = null;
                    }
                    this.logsDrawerOpen = false;
                    this.logsDrawerDeployment = null;
                    this.logsDrawerLogs = [];
                },
                getServiceName(deployment) {
                    if (!deployment) return '';
                    if (deployment.service_name) return deployment.service_name;
                    const service = this.services.find(s => s.id === deployment.service_id);
                    return service ? service.name : 'Unknown';
                },
                getStatusText(status) {
                    const statusMap = {
                        'queued': 'QUEUED',
                        'running': 'IN PROGRESS',
                        'success': 'SUCCESS',
                        'failed': 'FAIL'
                    };
                    return statusMap[status] || status.toUpperCase();
                }
            }
        }).mount('#app');
    </script>
    {% endraw %}
</body>
</html>
